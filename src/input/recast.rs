use std::{collections::HashSet, io::Read};

use glam::{U16Vec3, UVec3, Vec2, Vec3, Vec3A, Vec3Swizzles};
use hashbrown::HashMap;
use serde::Deserialize;

use crate::{Layer, Mesh, Polygon, U32Layer, Vertex};

/// A rasterized mesh generated by Recast.
///
/// Compared to the [detailed mesh](RecastDetailedMesh):
/// - it is made of polygons instead of triangles
/// - shapes are less detailed
/// - it has areas and flags that can be used to customize pathfinding
#[derive(Debug, Clone, Deserialize)]
pub struct RecastPolyMesh {
    /// The mesh vertices.
    pub vertices: Vec<UVec3>,
    /// Polygon and neighbor data. [Length: [`Self::polygon_count`] * 2 * [`Self::vertices_per_polygon`]
    pub polygons: Vec<u16>,
    /// The region id assigned to each polygon.
    pub regions: Vec<String>,
    /// The flags assigned to each polygon.
    pub flags: Vec<u16>,
    /// The area id assigned to each polygon.
    pub areas: Vec<u8>,
    /// The number of allocated polygons
    pub max_polygons: usize,
    /// The maximum number of vertices per polygon
    pub vertices_per_polygon: usize,
    /// The bounding box of the mesh in world space.
    pub aabb: Aabb3d,
    /// The size of each cell. (On the xz-plane.)
    pub cell_size: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    pub cell_height: f32,
    /// The AABB border size used to generate the source data from which the mesh was derived.
    pub border_size: u16,
    /// The max error of the polygon edges in the mesh.
    pub max_edge_error: f32,
}

#[derive(Debug, Default, Clone, PartialEq, Deserialize, Copy)]
pub struct Aabb3d {
    pub min: Vec3,
    pub max: Vec3,
}

impl RecastPolyMesh {
    /// Parse a RecastPolygonMesh from a file.
    pub fn from_file(path: &str) -> Self {
        let mut file = std::fs::File::open(path).unwrap();
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer).unwrap();
        Self::from_bytes(&buffer)
    }

    /// Parse a RecastPolygonMesh from a byte slice.
    pub fn from_bytes(bytes: &[u8]) -> Self {
        serde_json::from_slice(bytes).unwrap()
    }

    fn areas(&self) -> Vec<u8> {
        let mut areas: Vec<u8> = self
            .areas
            .iter()
            .cloned()
            .collect::<HashSet<_>>()
            .into_iter()
            .collect();
        areas.sort();
        if let Some(255) = areas.last() {
            areas.pop();
            areas.insert(0, 255);
        }
        areas
    }
}

/// Contains triangle meshes that represent detailed height data associated
/// with the polygons in its associated polygon mesh object.
#[derive(Debug, Clone, Deserialize)]
pub struct RecastPolyMeshDetail {
    /// The sub-mesh data
    pub meshes: Vec<SubMesh>,
    /// The mesh vertices
    pub vertices: Vec<Vec3A>,
    /// The mesh triangles and their associated metadata
    pub triangles: Vec<(U16Vec3, usize)>,
}

#[derive(Debug, Clone, Copy, Deserialize)]
pub struct SubMesh {
    pub first_vertex_index: usize,
    pub vertex_count: usize,
    pub first_triangle_index: usize,
    pub triangle_count: usize,
}

impl RecastPolyMeshDetail {
    /// Get the list of vertex IDs for each triangle in the mesh.
    fn triangles(&self) -> Vec<[usize; 3]> {
        self.meshes
            .iter()
            .flat_map(|mesh| {
                self.triangles
                    .iter()
                    .skip(mesh.first_triangle_index)
                    .take(mesh.triangle_count)
                    .map(|&(t, _)| {
                        [
                            t.x as usize + mesh.first_vertex_index,
                            t.y as usize + mesh.first_vertex_index,
                            t.z as usize + mesh.first_vertex_index,
                        ]
                    })
            })
            .collect()
    }

    fn common_vertices(&self) -> HashMap<u32, Vec<u32>> {
        self.vertices
            .iter()
            .enumerate()
            .map(|(i, v)| {
                (
                    i as u32,
                    self.vertices
                        .iter()
                        .enumerate()
                        .filter_map(|(i2, v2)| (v == v2).then_some(i2 as u32))
                        .collect(),
                )
            })
            .collect()
    }

    /// Parse a RecastPolygonMeshDetail from a file.
    pub fn from_file(path: &str) -> Self {
        let mut file = std::fs::File::open(path).unwrap();
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer).unwrap();
        Self::from_bytes(&buffer)
    }

    /// Parse a RecastPolygonMeshDetail from a byte slice.
    pub fn from_bytes(bytes: &[u8]) -> Self {
        serde_json::from_slice(bytes).unwrap()
    }
}

impl From<RecastPolyMeshDetail> for Mesh {
    fn from(detailed_mesh: RecastPolyMeshDetail) -> Self {
        let common = detailed_mesh.common_vertices();
        let mut layer =
            Layer::new(
                detailed_mesh
                    .vertices
                    .iter()
                    .enumerate()
                    .map(|(i, v)| {
                        Vertex::new(
                            Vec2::new(v.x, v.z),
                            detailed_mesh
                                .triangles()
                                .iter()
                                .enumerate()
                                .filter_map(|(n, p)| {
                                    common.get(&(i as u32)).unwrap().iter().find_map(|ii| {
                                        p.contains(&(*ii as usize)).then_some(n as u32)
                                    })
                                })
                                .collect(),
                        )
                    })
                    .collect(),
                detailed_mesh
                    .triangles()
                    .into_iter()
                    .map(|p| Polygon::new(vec![p[2] as u32, p[1] as u32, p[0] as u32], false))
                    .collect(),
            )
            .unwrap();
        layer.height = detailed_mesh.vertices.iter().map(|v| v.y).collect();

        let mut detailed_navmesh = Mesh {
            layers: vec![layer],
            ..Default::default()
        };
        detailed_navmesh.reorder_neighbors_ccw_and_fix_corners();
        detailed_navmesh.update_is_one_way();
        #[cfg(not(feature = "no-default-baking"))]
        detailed_navmesh.bake();

        detailed_navmesh
    }
}

/// A combined mesh from recast
#[derive(Debug, Clone)]
pub struct RecastFullMesh {
    rasterised: RecastPolyMesh,
    detailed: RecastPolyMeshDetail,
}

impl RecastFullMesh {
    /// Create a new `RecastFullMesh` from the combined polygon mesh and detailed mesh from recast.
    pub fn new(rasterised: RecastPolyMesh, detailed: RecastPolyMeshDetail) -> Self {
        Self {
            rasterised,
            detailed,
        }
    }

    fn triangles_with_mesh_info(&self) -> Vec<PolygonWithMeshInfo> {
        self.detailed
            .meshes
            .iter()
            .zip(self.rasterised.areas.iter())
            .flat_map(|(mesh, mesh_area)| {
                self.detailed
                    .triangles
                    .iter()
                    .skip(mesh.first_triangle_index)
                    .take(mesh.triangle_count)
                    .map(|&(t, _)| PolygonWithMeshInfo {
                        vertices: [
                            t.x as usize + mesh.first_vertex_index,
                            t.y as usize + mesh.first_vertex_index,
                            t.z as usize + mesh.first_vertex_index,
                        ],
                        mesh_area: *mesh_area,
                    })
            })
            .collect()
    }
}

struct PolygonWithMeshInfo {
    vertices: [usize; 3],
    mesh_area: u8,
}

impl From<RecastFullMesh> for Mesh {
    fn from(full: RecastFullMesh) -> Self {
        let common = full.detailed.common_vertices();
        let triangles_with_mesh_info = full.triangles_with_mesh_info();
        let areas = full.rasterised.areas();
        let reindexed_polygons: HashMap<u8, HashMap<usize, u32>> = areas
            .iter()
            .map(|area| {
                (
                    *area,
                    triangles_with_mesh_info
                        .iter()
                        .enumerate()
                        .filter_map(|(original_index, polygon)| {
                            (*area == polygon.mesh_area).then_some(original_index)
                        })
                        .enumerate()
                        .map(|(layer_index, original_index)| {
                            (
                                original_index,
                                U32Layer::from_layer_and_polygon(
                                    if *area == 255 { 0 } else { *area },
                                    layer_index as u32,
                                ),
                            )
                        })
                        .collect::<HashMap<usize, u32>>(),
                )
            })
            .collect();

        let layers = areas
            .iter()
            .map(|area| {
                let mut layer = Layer {
                    vertices: full
                        .detailed
                        .vertices
                        .iter()
                        .enumerate()
                        .map(|(vertex_index, vertex)| {
                            Vertex::new(
                                vertex.xz(),
                                triangles_with_mesh_info
                                    .iter()
                                    .enumerate()
                                    .filter_map(|(polygon_index, polygon)| {
                                        common.get(&(vertex_index as u32)).unwrap().iter().find_map(
                                            |common_vertex_index| {
                                                polygon
                                                    .vertices
                                                    .contains(&(*common_vertex_index as usize))
                                                    .then(|| {
                                                        reindexed_polygons
                                                            .get(&polygon.mesh_area)
                                                            .unwrap()
                                                            .get(&polygon_index)
                                                            .cloned()
                                                    })
                                                    .flatten()
                                            },
                                        )
                                    })
                                    .collect(),
                            )
                        })
                        .collect(),
                    polygons: triangles_with_mesh_info
                        .iter()
                        .filter_map(|polygon| (polygon.mesh_area == *area).then_some(polygon))
                        .map(|polygon| {
                            let p = Polygon::new(
                                vec![
                                    polygon.vertices[2] as u32,
                                    polygon.vertices[1] as u32,
                                    polygon.vertices[0] as u32,
                                ],
                                false,
                            );
                            p
                        })
                        .collect(),
                    ..Default::default()
                };
                layer.height = full.detailed.vertices.iter().map(|v| v.y).collect();
                // TODO: islands baking doesn't work on stitched layers, don't do it for now
                #[cfg(not(feature = "no-default-baking"))]
                layer.bake_polygon_finder();
                layer
            })
            .collect();

        let mut full_navmesh = Mesh {
            layers,
            ..Default::default()
        };

        if !areas.is_empty() {
            full_navmesh.remove_useless_vertices();
        }
        full_navmesh.reorder_neighbors_ccw_and_fix_corners();
        full_navmesh.update_is_one_way();

        full_navmesh
    }
}
