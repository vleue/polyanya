use std::io::Read;

use glam::{UVec3, Vec2, Vec3, Vec3Swizzles};
use hashbrown::HashMap;
use serde::Deserialize;

use crate::{Layer, Mesh, Polygon, Vertex};

/// A rasterized mesh generated by Recast.
///
/// Compared to the [detailed mesh](RecastDetailedMesh):
/// - it is made of polygons instead of triangles
/// - shapes are less detailed
/// - it has areas and flags that can be used to customize pathfinding
#[derive(Debug, Default, Clone, PartialEq, Deserialize)]
pub struct RecastPolyMesh {
    /// The mesh vertices.
    pub vertices: Vec<UVec3>,
    /// Polygon and neighbor data. [Length: [`Self::polygon_count`] * 2 * [`Self::vertices_per_polygon`]
    pub polygons: Vec<u16>,
    /// The region id assigned to each polygon.
    pub regions: Vec<String>,
    /// The flags assigned to each polygon.
    pub flags: Vec<u16>,
    /// The area id assigned to each polygon.
    pub areas: Vec<u8>,
    /// The number of allocated polygons
    pub max_polygons: usize,
    /// The maximum number of vertices per polygon
    pub vertices_per_polygon: usize,
    /// The bounding box of the mesh in world space.
    pub aabb: Aabb3d,
    /// The size of each cell. (On the xz-plane.)
    pub cell_size: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    pub cell_height: f32,
    /// The AABB border size used to generate the source data from which the mesh was derived.
    pub border_size: u16,
    /// The max error of the polygon edges in the mesh.
    pub max_edge_error: f32,
}

#[derive(Debug, Default, Clone, PartialEq, Deserialize, Copy)]
pub struct Aabb3d {
    pub min: Vec3,
    pub max: Vec3,
}

impl RecastPolyMesh {
    /// Get the list of vertex IDs for each polygon in the mesh.
    pub fn polygons(&self) -> Vec<Vec<u16>> {
        self.polygons
            .chunks(self.vertices_per_polygon * 2)
            .map(|chunk| {
                chunk
                    .iter()
                    .take(self.vertices_per_polygon)
                    .take_while(|p| **p != u16::MAX)
                    .cloned()
                    .collect::<Vec<_>>()
            })
            .collect()
    }

    /// Parse a RecastPolygonMesh from a file.
    pub fn from_file(path: &str) -> Self {
        let mut file = std::fs::File::open(path).unwrap();
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer).unwrap();
        Self::from_bytes(&buffer)
    }

    /// Parse a RecastPolygonMesh from a byte slice.
    pub fn from_bytes(bytes: &[u8]) -> Self {
        serde_json::from_slice(bytes).unwrap()
    }
}

impl From<RecastPolyMesh> for Mesh {
    fn from(polygon_mesh: RecastPolyMesh) -> Self {
        let mut layer = Layer::new(
            polygon_mesh
                .vertices
                .iter()
                .enumerate()
                .map(|(i, v)| {
                    Vertex::new(
                        Vec2::new(
                            v.x as f32 * polygon_mesh.cell_size,
                            v.z as f32 * polygon_mesh.cell_size,
                        ) + polygon_mesh.aabb.min.xz(),
                        polygon_mesh
                            .polygons()
                            .iter()
                            .enumerate()
                            .filter_map(|(n, p)| p.contains(&(i as u16)).then_some(n as u32))
                            .collect(),
                    )
                })
                .collect(),
            polygon_mesh
                .polygons()
                .into_iter()
                .map(|p| {
                    let mut p: Vec<_> = p.into_iter().map(|i| i as u32).collect();
                    p.reverse();
                    // TODO: compute the is_one_way flag from the second half of the polygon data
                    Polygon::new(p.into_iter().map(|i| i).collect(), false)
                })
                .collect(),
        )
        .unwrap();
        layer.height = polygon_mesh
            .vertices
            .iter()
            .map(|v| v.y as f32 * polygon_mesh.cell_height + polygon_mesh.aabb.min.y)
            .map(|h| h)
            .collect();

        let mut navmesh = Mesh {
            layers: vec![layer],
            ..Default::default()
        };
        navmesh.reorder_neighbors_ccw_and_fix_corners();
        #[cfg(not(feature = "no-default-baking"))]
        navmesh.bake();
        navmesh
    }
}

/// A detailed mesh generated by Recast.
///
/// Compared to the [polygon mesh](RecastPolygonMesh):
/// - it is made of triangles instead of polygons
/// - shapes are more detailed
/// - it doesn't have any information about extra configuration
#[derive(Debug, Default, Clone, PartialEq, Deserialize)]
pub struct RecastPolyMeshDetail {
    /// Group of triangles that makes a polygon
    pub meshes: Vec<SubMesh>,
    /// The mesh vertices
    pub vertices: Vec<Vec3>,
    /// Index of a triangle vertices, needs to be offset by the submesh owning a triangle
    ///
    /// Last value is a flag indicating if the triangle edges are internal or external,
    ///
    /// See <https://recastnav.com/structrcPolyMeshDetail.html#a05e186a92fad184179c726debb033979> for more details
    pub triangles: Vec<([u32; 3], u32)>,
}

#[derive(Debug, Default, Clone, PartialEq, Deserialize, Copy)]
pub struct SubMesh {
    pub first_vertex_index: u32,
    pub vertex_count: u32,
    pub first_triangle_index: u32,
    pub triangle_count: u32,
}

impl RecastPolyMeshDetail {
    /// Get the list of vertex IDs for each triangle in the mesh.
    pub fn triangles(&self) -> Vec<[u32; 3]> {
        self.meshes
            .iter()
            .flat_map(|mesh| {
                self.triangles
                    .iter()
                    .skip(mesh.first_triangle_index as usize)
                    .take(mesh.triangle_count as usize)
                    .map(|&([a, b, c], _)| {
                        [
                            a + mesh.first_vertex_index,
                            b + mesh.first_vertex_index,
                            c + mesh.first_vertex_index,
                        ]
                    })
            })
            .collect()
    }

    fn common_vertices(&self) -> HashMap<u32, Vec<u32>> {
        self.vertices
            .iter()
            .enumerate()
            .map(|(i, v)| {
                (
                    i as u32,
                    self.vertices
                        .iter()
                        .enumerate()
                        .filter_map(|(i2, v2)| (v == v2).then_some(i2 as u32))
                        .collect(),
                )
            })
            .collect()
    }

    /// Parse a RecastPolygonMeshDetail from a file.
    pub fn from_file(path: &str) -> Self {
        let mut file = std::fs::File::open(path).unwrap();
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer).unwrap();
        Self::from_bytes(&buffer)
    }

    /// Parse a RecastPolygonMeshDetail from a byte slice.
    pub fn from_bytes(bytes: &[u8]) -> Self {
        serde_json::from_slice(bytes).unwrap()
    }
}

impl From<RecastPolyMeshDetail> for Mesh {
    fn from(detailed_mesh: RecastPolyMeshDetail) -> Self {
        let common = detailed_mesh.common_vertices();
        let mut layer = Layer::new(
            detailed_mesh
                .vertices
                .iter()
                .enumerate()
                .map(|(i, v)| {
                    Vertex::new(
                        Vec2::new(v.x, v.z),
                        detailed_mesh
                            .triangles()
                            .iter()
                            .enumerate()
                            .filter_map(|(n, p)| {
                                common
                                    .get(&(i as u32))
                                    .unwrap()
                                    .iter()
                                    .find_map(|ii| p.contains(ii).then_some(n as u32))
                            })
                            .collect(),
                    )
                })
                .collect(),
            detailed_mesh
                .triangles()
                .into_iter()
                // TODO: compute the is_one_way flag from the triangle flags
                .map(|p| Polygon::new(vec![p[2], p[1], p[0]], false))
                .collect(),
        )
        .unwrap();
        layer.height = detailed_mesh.vertices.iter().map(|v| v.y).collect();

        let mut detailed_navmesh = Mesh {
            layers: vec![layer],
            ..Default::default()
        };
        detailed_navmesh.reorder_neighbors_ccw_and_fix_corners();
        #[cfg(not(feature = "no-default-baking"))]
        detailed_navmesh.bake();
        detailed_navmesh
    }
}
